// Copyright 2017 aaharu All rights reserved.
// This source code is licensed under the BSD-style license found in
// the LICENSE file in the root directory of this source tree.

// This source code use following software(s):
//   - go-jsschema https://github.com/lestrrat/go-jsschema
//     Copyright (c) 2016 lestrrat

package schemarshal

import (
	"fmt"
	"strings"

	"github.com/lestrrat/go-jsschema"
)

// GenerateGoFile is a generator that define struct from JSON Schema
func GenerateGoFile(s *schema.Schema, defaultTypeName string, packageName string, command string) (string, error) {
	var str string
	str += fmt.Sprintf("// generated by `%s`\n\npackage %s\n\n", command, packageName)
	str += fmt.Sprintf("import \"time\"\n\n")
	name := defaultTypeName
	if s.Title != "" {
		name = s.Title
	}
	genarated, err := schemaToStruct(s, name, 0)
	str += genarated
	return str, err
}

func schemaToStruct(s *schema.Schema, name string, nestLevel int) (string, error) {
	var str string

	if nestLevel == 0 {
		str += "type"
		str += " "
	} else {
		for i := 1; i <= nestLevel; i++ {
			str += "\t"
		}
	}
	str += ucfirst(name)
	str += " "

	genarated, err := typeDef(s, nestLevel)
	if err != nil {
		return "", err
	}
	str += genarated

	if nestLevel == 0 {
		str += "\n"
	} else {
		str += " "
		str += "`json:\"" + name + "\"`"
		str += "\n"
	}

	return str, nil
}

func typeDef(s *schema.Schema, nestLevel int) (string, error) {
	var str string
	if searchPrimitiveTypes(s.Type, schema.IntegerType) {
		if searchPrimitiveTypes(s.Type, schema.NullType) {
			str += "*"
		}
		str += "int"
	} else if searchPrimitiveTypes(s.Type, schema.StringType) {
		if searchPrimitiveTypes(s.Type, schema.NullType) {
			str += "*"
		}
		if s.Format == schema.FormatDateTime {
			str += "time.Time"
		} else {
			str += "string"
		}
	} else if searchPrimitiveTypes(s.Type, schema.ObjectType) {
		str += "struct {\n"
		for key, propSchema := range s.Properties {
			tmp, err := schemaToStruct(propSchema, key, nestLevel+1)
			if err != nil {
				return "", err
			}
			str += tmp
		}
		for i := 1; i <= nestLevel; i++ {
			str += "\t"
		}
		str += "}"
	} else if searchPrimitiveTypes(s.Type, schema.ArrayType) {
		if s.Items == nil {
			str += "[]interface{}"
		} else if s.Items.TupleMode {
			// unsupported
			err := fmt.Errorf("unsupported type %v", s.Items)
			return "", err
		} else {
			str += "[]"
			tmp, err := typeDef(s.Items.Schemas[0], nestLevel)
			if err != nil {
				return "", err
			}
			str += tmp
		}
	} else if searchPrimitiveTypes(s.Type, schema.BooleanType) {
		if searchPrimitiveTypes(s.Type, schema.NullType) {
			str += "*"
		}
		str += "bool"
	} else if searchPrimitiveTypes(s.Type, schema.NumberType) {
		if searchPrimitiveTypes(s.Type, schema.NullType) {
			str += "*"
		}
		str += "float64"
	}
	return str, nil
}

func searchPrimitiveTypes(a schema.PrimitiveTypes, x schema.PrimitiveType) bool {
	for i := 0; i < len(a); i++ {
		if a[i] == x {
			return true
		}
	}
	return false
}

func ucfirst(str string) string {
	return strings.Replace(strings.Title(str), " ", "", -1)
}
