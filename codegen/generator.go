// Copyright 2017 aaharu All rights reserved.
// This source code is licensed under the BSD-style license found in
// the LICENSE file in the root directory of this source tree.

package codegen

import (
	"bytes"
	"fmt"
	"go/format"

	"github.com/aaharu/schemarshal/version"
)

type Generator struct {
	name    string // package nage
	command string
	imports []*ImportSpec
	decls   []*TypeSpec
}

func NewGenerator(packageName string, command string) *Generator {
	return &Generator{
		name:    packageName,
		command: command,
	}
}

func (g *Generator) AddImport(spec *ImportSpec) {
	if g.imports == nil {
		g.imports = []*ImportSpec{}
	}
	g.imports = append(g.imports, spec)
}

func (g *Generator) AddType(ts *TypeSpec) {
	if g.decls == nil {
		g.decls = []*TypeSpec{}
	}
	g.decls = append(g.decls, ts)
}

func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("// generated by %s `%s`\n", version.String(), g.command))
	buf.WriteString("\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.name))

	if len(g.imports) > 1 {
		buf.WriteString(fmt.Sprintf("import (\n"))
		for i := range g.imports {
			buf.WriteString(fmt.Sprintf("%s %s\n", g.imports[i].Name, g.imports[i].Path))
		}
		buf.WriteString(fmt.Sprintf(")\n\n"))
	} else if len(g.imports) == 1 {
		buf.WriteString(fmt.Sprintf("import %s %s\n\n", g.imports[0].Name, g.imports[0].Path))
	}

	if g.decls != nil {
		for i := range g.decls {
			buf.WriteString("type " + g.decls[i].Name + " ")
			buf.Write(g.decls[i].Type.Generate())
			buf.WriteString("\n")
		}
	}

	return format.Source(buf.Bytes())
}

type ImportSpec struct {
	Name string // ident
	Path string
}

type TypeSpec struct {
	Name string // type name
	Type *JSONType
}

type Format int

const (
	OBJECT Format = iota
	ARRAY
	STRING
	BOOLEAN
	NUMBER
	INTEGER
	DATETIME
)

type JSONType struct {
	Format   Format
	Nullable bool
	Fields   []*Field // object
	ItemType *JSONType
}

func (t *JSONType) AddField(field *Field) {
	if t.Fields == nil {
		t.Fields = []*Field{}
	}
	t.Fields = append(t.Fields, field)
}

func (t *JSONType) Generate() []byte {
	var buf bytes.Buffer
	if t.Nullable {
		buf.WriteString("*")
	}
	if t.Format == OBJECT {
		if t.Fields == nil {
			buf.WriteString("map[string]interface{}\n")
		} else {
			buf.WriteString("struct {\n")
			for i := range t.Fields {
				buf.WriteString(t.Fields[i].Name)
				buf.WriteString(" ")
				buf.Write(t.Fields[i].Type.Generate())
				buf.WriteString(" ")
				buf.Write(t.Fields[i].Tag.Generate())
				buf.WriteString("\n")
			}
			buf.WriteString("}")
		}
	} else if t.Format == ARRAY {
		buf.WriteString("[]")
		buf.Write(t.ItemType.Generate())
	} else if t.Format == STRING {
		buf.WriteString("string")
	} else if t.Format == BOOLEAN {
		buf.WriteString("bool")
	} else if t.Format == NUMBER {
		buf.WriteString("float64")
	} else if t.Format == INTEGER {
		buf.WriteString("int")
	} else if t.Format == DATETIME {
		buf.WriteString("time.Time")
	}
	return buf.Bytes()
}

type Field struct {
	Name string
	Type *JSONType
	Tag  *JSONTag
}

type JSONTag struct {
	Name      string
	OmitEmpty bool
}

func (t *JSONTag) Generate() []byte {
	var buf bytes.Buffer
	buf.WriteString("`json:\"")
	buf.WriteString(t.Name)
	if t.OmitEmpty {
		buf.WriteString(",omitempty")
	}
	buf.WriteString("\"`")
	return buf.Bytes()
}
