// Copyright 2017 aaharu All rights reserved.
// This source code is licensed under the BSD-style license found in
// the LICENSE file in the root directory of this source tree.

package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aaharu/schemarshal/utils"
	"github.com/aaharu/schemarshal/version"
)

var enumList = map[string][]interface{}{} // FIXME

// Generator of Go source code from JSON Schema
type Generator struct {
	name    string // package nage
	command string
	imports []*importSpec
	decls   []*typeSpec
}

// NewGenerator create Generator struct
func NewGenerator(packageName string, command string) *Generator {
	return &Generator{
		name:    packageName,
		command: command,
	}
}

// AddImport add an import statement
func (g *Generator) AddImport(path string, name string) {
	if g.imports == nil {
		g.imports = []*importSpec{}
	}
	g.imports = append(g.imports, &importSpec{
		name: name,
		path: path,
	})
}

// AddType add a type statement
func (g *Generator) AddType(name string, jsonType *JSONType) {
	if g.decls == nil {
		g.decls = []*typeSpec{}
	}
	g.decls = append(g.decls, &typeSpec{
		name:     name,
		jsontype: jsonType,
	})
}

// Generate gofmt-ed Go source code
func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("// generated by %s `%s`\n", version.String(), g.command))
	buf.WriteString("\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.name))

	if len(g.imports) > 1 {
		buf.WriteString(fmt.Sprintf("import (\n"))
		for i := range g.imports {
			buf.WriteString(fmt.Sprintf("%s %s\n", g.imports[i].name, g.imports[i].path))
		}
		buf.WriteString(fmt.Sprintf(")\n\n"))
	} else if len(g.imports) == 1 {
		buf.WriteString(fmt.Sprintf("import %s %s\n\n", g.imports[0].name, g.imports[0].path))
	}

	if g.decls != nil {
		for i := range g.decls {
			buf.WriteString("type " + g.decls[i].name + " ")
			buf.Write(g.decls[i].jsontype.generate())
			buf.WriteString("\n")
		}
	}

	if len(enumList) > 0 {
		buf.WriteString("\n")
		for typeName, enum := range enumList {
			enumName := typeName + "Enum"
			buf.WriteString("type " + enumName + " int\n")
			buf.WriteString("const (\n")
			for i := range enum {
				if i == 0 {
					buf.WriteString(enumName + utils.UpperCamelCase(fmt.Sprintf("%v", enum[0])) + " " + enumName + " = iota\n")
				} else {
					buf.WriteString(enumName + utils.UpperCamelCase(fmt.Sprintf("%v", enum[i])) + "\n")
				}
			}
			buf.WriteString(")\n")
			buf.WriteString("func (enum " + enumName + ") MarshalJSON() ([]byte, error) {\n")
			buf.WriteString("var var" + typeName + " = []interface{}{")
			for i := range enum {
				switch v := enum[i].(type) {
				case string:
					buf.WriteString(`"`)
					buf.WriteString(strings.Replace(v, `"`, `\"`, -1))
					buf.WriteString(`"`)
				default:
					buf.WriteString(fmt.Sprintf("%v", v))
				}
				buf.WriteString(",")
			}
			buf.WriteString("}\n")
			buf.WriteString("switch v:= var" + typeName + "[enum].(type) {\n")
			buf.WriteString("case string:\n")
			buf.WriteString("return []byte(fmt.Sprintf(\"\\\"%v\\\"\", strings.Replace(v, `\"`, `\\\"`, -1))), nil\n")
			buf.WriteString("default:\n")
			buf.WriteString("return []byte(fmt.Sprintf(\"%v\", v)), nil\n")
			buf.WriteString("}\n")
			buf.WriteString("}\n\n")
		}
	}

	return format.Source(buf.Bytes())
}

type importSpec struct {
	name string // ident
	path string
}

type typeSpec struct {
	name     string // type name
	jsontype *JSONType
}

type jsonFormat int

const (
	formatObject jsonFormat = iota
	formatArray
	formatString
	formatBoolean
	formatNumber
	formatInteger
	formatDatetime
)

// JSONType ...
type JSONType struct {
	format   jsonFormat
	nullable bool
	fields   []*field  // only object
	itemType *JSONType // only array
	enumType string
}

// AddField ...
func (t *JSONType) AddField(f *field) {
	if t.fields == nil {
		t.fields = []*field{}
	}
	t.fields = append(t.fields, f)
}

func (t *JSONType) generate() []byte {
	var buf bytes.Buffer
	if t.nullable {
		buf.WriteString("*")
	}
	if t.format == formatObject {
		if t.fields == nil {
			buf.WriteString("map[string]interface{}")
		} else {
			buf.WriteString("struct {\n")
			for i := range t.fields {
				buf.WriteString(t.fields[i].name)
				buf.WriteString(" ")
				buf.Write(t.fields[i].jsontype.generate())
				buf.WriteString(" ")
				buf.Write(t.fields[i].jsontag.generate())
				buf.WriteString("\n")
			}
			buf.WriteString("}")
		}
	} else if t.format == formatArray {
		buf.WriteString("[]")
		buf.Write(t.itemType.generate())
	} else if t.format == formatString {
		buf.WriteString("string")
	} else if t.format == formatBoolean {
		buf.WriteString("bool")
	} else if t.format == formatNumber {
		buf.WriteString("float64")
	} else if t.format == formatInteger {
		buf.WriteString("int")
	} else if t.format == formatDatetime {
		buf.WriteString("time.Time")
	}
	return buf.Bytes()
}

type field struct {
	name     string
	jsontype *JSONType
	jsontag  *jsonTag
}

type jsonTag struct {
	name      string
	omitEmpty bool
}

// Generate JSON tag code
func (t *jsonTag) generate() []byte {
	var buf bytes.Buffer
	buf.WriteString("`json:\"")
	buf.WriteString(t.name)
	if t.omitEmpty {
		buf.WriteString(",omitempty")
	}
	buf.WriteString("\"`")
	return buf.Bytes()
}
